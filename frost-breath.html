<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frost Breath</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&family=Patrick+Hand&display=swap');
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        outside: '#1a2a3a',
                        glass: '#e8f4f8',
                        fog: '#ffffff',
                        clear: '#2a4a6a',
                        frost: '#a8d8ea',
                        breath: '#f0f8ff',
                    },
                    fontFamily: {
                        finger: ['Caveat', 'cursive'],
                        hand: ['Patrick Hand', 'cursive'],
                    },
                },
            },
        };
    </script>
</head>
<body class="overflow-hidden">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Vocabulary
        const vocabulary = [
            { id: 1, word: 'glacial', definition: 'extremely cold or icy', hint: 'like ancient ice' },
            { id: 2, word: 'crystalline', definition: 'clear and transparent like crystal', hint: 'pure, glass-like' },
            { id: 3, word: 'ethereal', definition: 'extremely delicate and light', hint: 'otherworldly' },
            { id: 4, word: 'pristine', definition: 'in its original condition; unspoiled', hint: 'pure, untouched' },
            { id: 5, word: 'serene', definition: 'calm, peaceful, and untroubled', hint: 'tranquil stillness' },
            { id: 6, word: 'luminescent', definition: 'emitting light not from heat', hint: 'cold glow' },
            { id: 7, word: 'ephemeral', definition: 'lasting for a very short time', hint: 'fleeting moment' },
            { id: 8, word: 'diaphanous', definition: 'light, delicate, and translucent', hint: 'sheer, gossamer' },
        ];

        // Helper to generate non-overlapping positions
        const generateNonOverlappingPositions = (count, existingPositions = []) => {
            const positions = [...existingPositions];
            const minDistance = 15; // Minimum distance between word centers (%)

            for (let i = positions.length; i < count; i++) {
                let attempts = 0;
                let validPosition = null;

                while (attempts < 50 && !validPosition) {
                    const candidate = {
                        x: 10 + Math.random() * 75,
                        y: 10 + Math.random() * 70,
                    };

                    let isValid = true;
                    for (const pos of positions) {
                        const dx = candidate.x - pos.x;
                        const dy = candidate.y - pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minDistance) {
                            isValid = false;
                            break;
                        }
                    }

                    if (isValid) {
                        validPosition = candidate;
                    }
                    attempts++;
                }

                // Fallback if no valid position found
                if (!validPosition) {
                    validPosition = {
                        x: 10 + Math.random() * 75,
                        y: 10 + Math.random() * 70,
                    };
                }

                positions.push(validPosition);
            }

            return positions;
        };

        function FrostBreath() {
            // Word states
            const [words, setWords] = useState([]);
            const [hoveredWord, setHoveredWord] = useState(null);
            const [revealedWord, setRevealedWord] = useState(null);
            const [masteredWords, setMasteredWords] = useState([]);
            const [fadingWords, setFadingWords] = useState([]);

            // Visual state
            const [condensation, setCondensation] = useState([]);
            const [breathSpots, setBreathSpots] = useState([]);
            const [sessionComplete, setSessionComplete] = useState(false);

            // Demo controls
            const [showDemoControls, setShowDemoControls] = useState(true);

            const audioContextRef = useRef(null);

            // Initialize
            useEffect(() => {
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();

                // Generate non-overlapping positions for words
                const positions = generateNonOverlappingPositions(vocabulary.length);

                const initialWords = vocabulary.map((v, i) => ({
                    ...v,
                    x: positions[i].x,
                    y: positions[i].y,
                    rotation: (Math.random() - 0.5) * 8,
                    attempts: 0,
                    mastered: false,
                }));
                setWords(initialWords);

                // Generate condensation drops on the glass
                const initialCondensation = [];
                for (let i = 0; i < 100; i++) {
                    initialCondensation.push({
                        id: i,
                        x: Math.random() * 100,
                        y: Math.random() * 100,
                        size: 1 + Math.random() * 3,
                        opacity: 0.02 + Math.random() * 0.05,
                    });
                }
                setCondensation(initialCondensation);

                return () => audioContextRef.current?.close();
            }, []);

            // Animate condensation slowly dripping
            useEffect(() => {
                const interval = setInterval(() => {
                    setCondensation(prev => prev.map(drop => ({
                        ...drop,
                        y: drop.y + 0.01,
                        opacity: drop.y > 95 ? 0 : drop.opacity,
                    })).map(drop => drop.y > 100 ? {
                        ...drop,
                        y: -2,
                        x: Math.random() * 100,
                        opacity: 0.02 + Math.random() * 0.05,
                    } : drop));
                }, 100);
                return () => clearInterval(interval);
            }, []);

            // Check completion
            useEffect(() => {
                if (masteredWords.length === vocabulary.length && !sessionComplete) {
                    setSessionComplete(true);
                    playSound('complete');
                }
            }, [masteredWords.length]);

            // Play sounds
            const playSound = useCallback((type) => {
                if (!audioContextRef.current) return;
                const ctx = audioContextRef.current;

                if (type === 'hover') {
                    // Soft glass touch
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = 600;
                    gain.gain.setValueAtTime(0.02, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
                    osc.connect(gain).connect(ctx.destination);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.2);
                } else if (type === 'reveal') {
                    // Clear chime
                    [1200, 1500, 1800].forEach((freq, i) => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.03, ctx.currentTime + i * 0.08);
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
                        osc.connect(gain).connect(ctx.destination);
                        osc.start(ctx.currentTime + i * 0.08);
                        osc.stop(ctx.currentTime + 0.5);
                    });
                } else if (type === 'clear') {
                    // Glass clearing - ascending brightness
                    [400, 600, 800, 1000, 1200].forEach((freq, i) => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.04, ctx.currentTime + i * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.5);
                        osc.connect(gain).connect(ctx.destination);
                        osc.start(ctx.currentTime + i * 0.1);
                        osc.stop(ctx.currentTime + 1.5);
                    });
                } else if (type === 'fog') {
                    // Fog returning
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.8);
                    gain.gain.setValueAtTime(0.06, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.8);
                    osc.connect(gain).connect(ctx.destination);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.8);
                } else if (type === 'complete') {
                    // Full window clear
                    const baseFreq = 440;
                    [1, 1.25, 1.5, 2, 2.5, 3].forEach((mult, i) => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = baseFreq * mult;
                        gain.gain.setValueAtTime(0.04, ctx.currentTime + i * 0.12);
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 3);
                        osc.connect(gain).connect(ctx.destination);
                        osc.start(ctx.currentTime + i * 0.12);
                        osc.stop(ctx.currentTime + 3);
                    });
                }
            }, []);

            // Handle word hover
            const handleHover = useCallback((wordId) => {
                const word = words.find(w => w.id === wordId);
                if (word && !word.mastered && !fadingWords.includes(wordId)) {
                    setHoveredWord(wordId);
                    playSound('hover');

                    // Add breath spot effect
                    setBreathSpots(prev => [...prev, {
                        id: Date.now(),
                        x: word.x,
                        y: word.y,
                    }]);
                    setTimeout(() => {
                        setBreathSpots(prev => prev.slice(1));
                    }, 2000);
                }
            }, [words, fadingWords, playSound]);

            // Handle word click
            const handleWordClick = useCallback((word) => {
                if (word.mastered || fadingWords.includes(word.id)) return;
                playSound('reveal');
                setRevealedWord(word);
            }, [fadingWords, playSound]);

            // Handle correct - clear the fog permanently
            const handleCorrect = useCallback(() => {
                if (!revealedWord) return;
                playSound('clear');

                setWords(prev => prev.map(w =>
                    w.id === revealedWord.id ? { ...w, mastered: true } : w
                ));
                setMasteredWords(prev => [...prev, revealedWord.id]);
                setRevealedWord(null);
            }, [revealedWord, playSound]);

            // Handle wrong - fog returns, word fades and respawns
            const handleWrong = useCallback(() => {
                if (!revealedWord) return;
                playSound('fog');

                setFadingWords(prev => [...prev, revealedWord.id]);

                setTimeout(() => {
                    setFadingWords(prev => prev.filter(id => id !== revealedWord.id));
                    setWords(prev => {
                        // Get existing positions (excluding the word being respawned)
                        const existingPositions = prev
                            .filter(w => w.id !== revealedWord.id)
                            .map(w => ({ x: w.x, y: w.y }));

                        // Generate new position that doesn't overlap
                        const newPositions = generateNonOverlappingPositions(
                            existingPositions.length + 1,
                            existingPositions
                        );
                        const newPos = newPositions[newPositions.length - 1];

                        return prev.map(w =>
                            w.id === revealedWord.id
                                ? {
                                    ...w,
                                    x: newPos.x,
                                    y: newPos.y,
                                    rotation: (Math.random() - 0.5) * 8,
                                    attempts: w.attempts + 1,
                                }
                                : w
                        );
                    });
                }, 1500);

                setRevealedWord(null);
            }, [revealedWord, playSound]);

            // Reset session
            const resetSession = useCallback(() => {
                const positions = generateNonOverlappingPositions(vocabulary.length);

                const newWords = vocabulary.map((v, i) => ({
                    ...v,
                    x: positions[i].x,
                    y: positions[i].y,
                    rotation: (Math.random() - 0.5) * 8,
                    attempts: 0,
                    mastered: false,
                }));
                setWords(newWords);
                setMasteredWords([]);
                setFadingWords([]);
                setSessionComplete(false);
                setRevealedWord(null);
            }, []);

            return (
                <div className="w-screen h-screen relative overflow-hidden">
                    {/* Outside scene - what you're looking at through the window */}
                    <div className="absolute inset-0 bg-gradient-to-b from-outside via-outside to-slate-900">
                        {/* Distant lights through window */}
                        <div className="absolute top-1/4 left-1/4 w-2 h-2 bg-yellow-200/30 rounded-full blur-sm" />
                        <div className="absolute top-1/3 right-1/3 w-1 h-1 bg-yellow-100/20 rounded-full blur-sm" />
                        <div className="absolute bottom-1/3 left-1/2 w-3 h-3 bg-blue-200/20 rounded-full blur-md" />
                    </div>

                    {/* The frosted glass pane */}
                    <div
                        className="absolute inset-0"
                        style={{
                            background: `
                                radial-gradient(ellipse at 30% 20%, rgba(255,255,255,0.15) 0%, transparent 50%),
                                radial-gradient(ellipse at 70% 80%, rgba(255,255,255,0.1) 0%, transparent 40%),
                                linear-gradient(180deg, rgba(200,220,240,0.08) 0%, rgba(180,200,220,0.12) 100%)
                            `,
                        }}
                    />

                    {/* Condensation drops on glass */}
                    {condensation.map(drop => (
                        <div
                            key={drop.id}
                            className="absolute rounded-full bg-white"
                            style={{
                                left: `${drop.x}%`,
                                top: `${drop.y}%`,
                                width: drop.size,
                                height: drop.size * 1.5,
                                opacity: drop.opacity,
                            }}
                        />
                    ))}

                    {/* Breath spots when hovering */}
                    {breathSpots.map(spot => (
                        <div
                            key={spot.id}
                            className="absolute rounded-full animate-breath-fade pointer-events-none"
                            style={{
                                left: `${spot.x}%`,
                                top: `${spot.y}%`,
                                width: '120px',
                                height: '120px',
                                transform: 'translate(-50%, -50%)',
                                background: 'radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%)',
                            }}
                        />
                    ))}

                    {/* Words written on the glass */}
                    {words.map(word => {
                        const isHovered = hoveredWord === word.id;
                        const isFading = fadingWords.includes(word.id);
                        const isMastered = word.mastered;

                        return (
                            <div
                                key={word.id}
                                className={`absolute cursor-pointer transition-all duration-500 select-none
                                          ${isFading ? 'animate-fog-return' : ''}`}
                                style={{
                                    left: `${word.x}%`,
                                    top: `${word.y}%`,
                                    transform: `translate(-50%, -50%) rotate(${word.rotation}deg)`,
                                }}
                                onMouseEnter={() => handleHover(word.id)}
                                onMouseLeave={() => setHoveredWord(null)}
                                onClick={() => handleWordClick(word)}
                            >
                                {/* Frost crystals for mastered words */}
                                {isMastered && (
                                    <div className="absolute inset-0 pointer-events-none">
                                        {/* Top-left crystal */}
                                        <svg className="absolute -top-3 -left-2 w-6 h-6 animate-frost-appear" style={{ animationDelay: '0s' }}>
                                            <path d="M3 12 L12 3 M6 12 L12 6 M9 12 L12 9" stroke="rgba(168, 216, 234, 0.6)" strokeWidth="1" fill="none"/>
                                        </svg>
                                        {/* Top-right crystal */}
                                        <svg className="absolute -top-3 -right-2 w-6 h-6 animate-frost-appear" style={{ animationDelay: '0.1s' }}>
                                            <path d="M12 12 L3 3 M9 12 L3 6 M6 12 L3 9" stroke="rgba(168, 216, 234, 0.5)" strokeWidth="1" fill="none"/>
                                        </svg>
                                        {/* Bottom-left crystal */}
                                        <svg className="absolute -bottom-3 -left-2 w-6 h-6 animate-frost-appear" style={{ animationDelay: '0.2s' }}>
                                            <path d="M3 3 L12 12 M6 3 L12 9 M9 3 L12 6" stroke="rgba(168, 216, 234, 0.4)" strokeWidth="1" fill="none"/>
                                        </svg>
                                        {/* Bottom-right crystal */}
                                        <svg className="absolute -bottom-3 -right-2 w-6 h-6 animate-frost-appear" style={{ animationDelay: '0.3s' }}>
                                            <path d="M12 3 L3 12 M9 3 L3 9 M6 3 L3 6" stroke="rgba(168, 216, 234, 0.5)" strokeWidth="1" fill="none"/>
                                        </svg>
                                        {/* Side crystals */}
                                        <svg className="absolute top-1/2 -left-4 w-4 h-4 -translate-y-1/2 animate-frost-appear" style={{ animationDelay: '0.15s' }}>
                                            <path d="M0 6 L12 6 M6 0 L6 12" stroke="rgba(168, 216, 234, 0.3)" strokeWidth="0.5" fill="none"/>
                                        </svg>
                                        <svg className="absolute top-1/2 -right-4 w-4 h-4 -translate-y-1/2 animate-frost-appear" style={{ animationDelay: '0.25s' }}>
                                            <path d="M0 6 L12 6 M6 0 L6 12" stroke="rgba(168, 216, 234, 0.3)" strokeWidth="0.5" fill="none"/>
                                        </svg>
                                    </div>
                                )}

                                {/* The finger-written word */}
                                <div
                                    className={`font-finger text-5xl md:text-6xl lg:text-7xl tracking-wide
                                              transition-all duration-500 whitespace-nowrap`}
                                    style={{
                                        // Three states of visibility through glass
                                        color: isMastered
                                            ? 'rgba(200, 230, 245, 0.85)' // Mastered - frosty blue, readable but behind glass
                                            : isHovered
                                                ? 'rgba(220, 235, 245, 0.75)' // Hovering - can read it now
                                                : 'rgba(180, 200, 220, 0.12)', // Default - barely visible, really obscured
                                        textShadow: isMastered
                                            ? '0 0 8px rgba(168, 216, 234, 0.4), 0 0 2px rgba(255,255,255,0.2)' // Frosty glow
                                            : isHovered
                                                ? '0 0 6px rgba(255,255,255,0.2)' // Slight glow when readable
                                                : '0 0 20px rgba(180,200,220,0.15)', // Heavy diffusion
                                        filter: isMastered
                                            ? 'none' // Sharp
                                            : isHovered
                                                ? 'blur(0.3px)' // Slight blur, but readable
                                                : 'blur(3px)', // Heavy blur - can barely make it out
                                    }}
                                >
                                    {word.word}
                                </div>

                                {/* Attempt marks */}
                                {word.attempts > 0 && !isMastered && (
                                    <div className="absolute -bottom-6 left-1/2 transform -translate-x-1/2
                                                  text-xs text-white/10">
                                        {Array(Math.min(word.attempts, 3)).fill('').map((_, i) => (
                                            <span key={i} className="inline-block w-1 h-1 rounded-full bg-white/20 mx-0.5" />
                                        ))}
                                    </div>
                                )}
                            </div>
                        );
                    })}

                    {/* Window frame edges */}
                    <div className="absolute inset-0 pointer-events-none"
                         style={{
                             boxShadow: 'inset 0 0 100px rgba(0,0,0,0.3), inset 0 0 200px rgba(0,0,0,0.1)',
                         }}
                    />

                    {/* Ice crystals in corners */}
                    <div className="absolute top-0 left-0 w-32 h-32 opacity-20"
                         style={{
                             background: 'linear-gradient(135deg, rgba(200,220,240,0.3) 0%, transparent 60%)',
                         }}
                    />
                    <div className="absolute top-0 right-0 w-32 h-32 opacity-20"
                         style={{
                             background: 'linear-gradient(225deg, rgba(200,220,240,0.3) 0%, transparent 60%)',
                         }}
                    />
                    <div className="absolute bottom-0 left-0 w-32 h-32 opacity-20"
                         style={{
                             background: 'linear-gradient(45deg, rgba(200,220,240,0.3) 0%, transparent 60%)',
                         }}
                    />
                    <div className="absolute bottom-0 right-0 w-32 h-32 opacity-20"
                         style={{
                             background: 'linear-gradient(315deg, rgba(200,220,240,0.3) 0%, transparent 60%)',
                         }}
                    />

                    {/* Reveal modal */}
                    {revealedWord && (
                        <div className="fixed inset-0 flex items-center justify-center z-50">
                            <div
                                className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                                onClick={() => setRevealedWord(null)}
                            />

                            <div className="relative bg-slate-800/95 border border-frost/30 p-8 rounded-lg max-w-md
                                          shadow-2xl backdrop-blur-md">
                                {/* Word */}
                                <div className="font-finger text-5xl text-frost text-center mb-4">
                                    {revealedWord.word}
                                </div>

                                {/* Definition */}
                                <div className="font-hand text-xl text-gray-300 text-center mb-2">
                                    {revealedWord.definition}
                                </div>

                                {/* Hint */}
                                <div className="text-sm text-frost/50 text-center mb-8 italic">
                                    {revealedWord.hint}
                                </div>

                                {/* Actions */}
                                <div className="flex gap-4 justify-center">
                                    <button
                                        onClick={handleCorrect}
                                        className="px-6 py-3 bg-clear/80 hover:bg-clear text-white
                                                 rounded-lg transition-all font-hand text-lg"
                                    >
                                        I knew it
                                    </button>
                                    <button
                                        onClick={handleWrong}
                                        className="px-6 py-3 bg-frost/20 hover:bg-frost/30 text-frost
                                                 rounded-lg transition-all font-hand text-lg"
                                    >
                                        Show me again
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Session complete */}
                    {sessionComplete && (
                        <div className="fixed inset-0 flex items-center justify-center z-40 pointer-events-none">
                            <div className="text-center">
                                <div className="font-finger text-5xl text-clear mb-4 animate-pulse">
                                    Window Clear
                                </div>
                                <div className="font-hand text-xl text-frost/70 mb-8">
                                    Every word now perfectly visible
                                </div>
                                <button
                                    onClick={resetSession}
                                    className="px-6 py-3 bg-frost/20 hover:bg-frost/30 text-frost
                                             rounded-lg transition-all pointer-events-auto font-hand"
                                >
                                    Breathe on Glass
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Progress */}
                    <div className="absolute bottom-4 left-4 text-white/20 text-xs font-hand">
                        <div>{masteredWords.length}/{vocabulary.length} clear</div>
                    </div>

                    {/* Time */}
                    <div className="absolute top-4 left-4 text-white/10 text-xs font-hand">
                        4:00 AM
                    </div>

                    {/* Demo Controls */}
                    {showDemoControls && (
                        <div className="absolute top-4 right-4 z-50">
                            <div className="bg-slate-800/95 border border-frost/20 p-4 rounded-lg backdrop-blur-sm max-w-xs">
                                <div className="text-xs mb-3 text-frost/70 font-bold font-hand">DEMO CONTROLS</div>

                                <div className="space-y-2 mb-3">
                                    <button
                                        onClick={() => {
                                            const unmasteredWord = words.find(w => !w.mastered);
                                            if (unmasteredWord) {
                                                setRevealedWord(unmasteredWord);
                                                setTimeout(() => handleCorrect(), 100);
                                            }
                                        }}
                                        className="w-full px-2 py-1 text-xs bg-clear/30 hover:bg-clear/50 text-white rounded border border-clear/50 font-hand"
                                    >
                                        Clear Next Word
                                    </button>
                                    <button
                                        onClick={() => {
                                            const unmasteredWord = words.find(w => !w.mastered);
                                            if (unmasteredWord) {
                                                setRevealedWord(unmasteredWord);
                                                setTimeout(() => handleWrong(), 100);
                                            }
                                        }}
                                        className="w-full px-2 py-1 text-xs bg-frost/20 hover:bg-frost/30 text-frost rounded border border-frost/30 font-hand"
                                    >
                                        Fog Returns
                                    </button>
                                    <button
                                        onClick={() => {
                                            // Simulate breath on glass
                                            setBreathSpots(prev => [...prev, {
                                                id: Date.now(),
                                                x: 30 + Math.random() * 40,
                                                y: 30 + Math.random() * 40,
                                            }]);
                                            setTimeout(() => {
                                                setBreathSpots(prev => prev.slice(1));
                                            }, 2000);
                                        }}
                                        className="w-full px-2 py-1 text-xs bg-white/10 hover:bg-white/20 text-white/70 rounded border border-white/20 font-hand"
                                    >
                                        Breath on Glass
                                    </button>
                                    <button
                                        onClick={() => playSound('complete')}
                                        className="w-full px-2 py-1 text-xs bg-frost/10 hover:bg-frost/20 text-frost/70 rounded border border-frost/20 font-hand"
                                    >
                                        Completion Sound
                                    </button>
                                </div>

                                {/* Mastered slider */}
                                <div className="mb-3">
                                    <label className="text-xs text-frost/50 block mb-1 font-hand">
                                        Clear: {masteredWords.length}/{vocabulary.length}
                                    </label>
                                    <input
                                        type="range"
                                        min="0"
                                        max={vocabulary.length}
                                        value={masteredWords.length}
                                        onChange={(e) => {
                                            const count = parseInt(e.target.value);
                                            const ids = vocabulary.slice(0, count).map(v => v.id);
                                            setMasteredWords(ids);
                                            setWords(prev => prev.map(w => ({
                                                ...w,
                                                mastered: ids.includes(w.id)
                                            })));
                                        }}
                                        className="w-full h-1 bg-frost/20 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>

                                {/* Reset */}
                                <button
                                    onClick={resetSession}
                                    className="w-full px-2 py-1 text-xs border border-frost/30 hover:bg-frost/10 text-frost/50 rounded font-hand"
                                >
                                    Reset Session
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Toggle demo */}
                    <button
                        onClick={() => setShowDemoControls(!showDemoControls)}
                        className="absolute bottom-4 right-4 text-white/20 hover:text-white/50 text-xs z-50 font-hand"
                    >
                        {showDemoControls ? 'Hide Demo' : 'Demo'}
                    </button>

                    <style>{`
                        @keyframes fog-return {
                            0% { opacity: 1; }
                            50% { opacity: 0.3; filter: blur(4px); }
                            100% { opacity: 0; }
                        }

                        .animate-fog-return {
                            animation: fog-return 1.5s ease-out forwards;
                        }

                        @keyframes breath-fade {
                            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                            30% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.3); }
                        }

                        .animate-breath-fade {
                            animation: breath-fade 2s ease-out forwards;
                        }

                        @keyframes clear-spot {
                            0% { opacity: 0; transform: scale(0.5); }
                            100% { opacity: 1; transform: scale(1); }
                        }

                        .animate-clear-spot {
                            animation: clear-spot 0.8s ease-out forwards;
                        }

                        @keyframes frost-appear {
                            0% { opacity: 0; transform: scale(0); }
                            50% { opacity: 1; transform: scale(1.2); }
                            100% { opacity: 1; transform: scale(1); }
                        }

                        .animate-frost-appear {
                            animation: frost-appear 0.5s ease-out forwards;
                        }
                    `}</style>
                </div>
            );
        }

        ReactDOM.render(<FrostBreath />, document.getElementById('root'));
    </script>
</body>
</html>
